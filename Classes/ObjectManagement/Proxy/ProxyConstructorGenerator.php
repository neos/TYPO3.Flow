<?php
namespace Neos\Flow\ObjectManagement\Proxy;

/*
 * This file is part of the Neos.Flow package.
 *
 * (c) Contributors of the Neos Project - www.neos.io
 *
 * This package is Open Source Software. For the full copyright and license
 * information, please view the LICENSE file which was distributed with this
 * source code.
 */

use Laminas\Code\Generator\DocBlockGenerator;
use Neos\Flow\ObjectManagement\DependencyInjection\ProxyClassBuilder;

final class ProxyConstructorGenerator extends ProxyMethodGenerator
{
    public function __construct($name = null, array $parameters = [], $flags = self::FLAG_PUBLIC, $body = null, $docBlock = null)
    {
        if ($docBlock === null) {
            $docBlock = new DocBlockGenerator();
        }
        $docBlock->setSourceContent(ProxyClassBuilder::AUTOGENERATED_PROXY_METHOD_COMMENT . PHP_EOL . PHP_EOL . $docBlock->getSourceContent());
        $docBlock->setWordWrap(false);
        $docBlock->setSourceDirty(false);
        parent::__construct('__construct', $parameters, $flags, $body, $docBlock);
    }

    public static function fromReflection(\Laminas\Code\Reflection\MethodReflection $reflectionMethod): static
    {
        $method = new static('__construct');
        $declaringClass = $reflectionMethod->getDeclaringClass();

        $method->fullOriginalClassName = $declaringClass->name;
        $method->setFinal($reflectionMethod->isFinal());

        if ($reflectionMethod->isPrivate()) {
            $method->setVisibility(self::VISIBILITY_PRIVATE);
        } elseif ($reflectionMethod->isProtected()) {
            $method->setVisibility(self::VISIBILITY_PROTECTED);
        } else {
            $method->setVisibility(self::VISIBILITY_PUBLIC);
        }

        if (!empty($reflectionMethod->getDocComment())) {
            $docBlock = DocBlockGenerator::fromReflection($reflectionMethod->getDocBlock());
            $docBlock->setSourceContent(ProxyClassBuilder::AUTOGENERATED_PROXY_METHOD_COMMENT . PHP_EOL . PHP_EOL . $docBlock->getSourceContent());
        } else {
            $docBlock = new DocBlockGenerator();
            $docBlock->setSourceContent(ProxyClassBuilder::AUTOGENERATED_PROXY_METHOD_COMMENT);
        }
        $docBlock->setWordWrap(false);
        $docBlock->setSourceDirty(false);
        $method->setDocBlock($docBlock);
        return $method;
    }

    /**
     * @throws \BadMethodCallException
     */
    public static function copyMethodSignature(\Laminas\Code\Reflection\MethodReflection $reflectionMethod): never
    {
        throw new \BadMethodCallException('copyMethodSignature() is not supported, nor needed for constructor proxies.', 1685078402);
    }

    public function renderBodyCode(): string
    {
        if ((trim($this->addedPreParentCallCode) === '' && trim($this->addedPostParentCallCode) === '')) {
            return '';
        }

        $callParentMethodCode = $this->buildCallParentMethodCode($this->fullOriginalClassName, $this->name);
        $this->addedPreParentCallCode = rtrim($this->addedPreParentCallCode);
        $this->addedPostParentCallCode = rtrim($this->addedPostParentCallCode);

        return
            ($callParentMethodCode !== '' ? $this->buildAssignMethodArgumentsCode() : '') .
            ($this->addedPreParentCallCode !== '' ? $this->addedPreParentCallCode . PHP_EOL : '') .
            $callParentMethodCode .
            ($this->addedPostParentCallCode !== '' ? $this->addedPostParentCallCode . PHP_EOL : '');
    }

    protected function buildAssignMethodArgumentsCode(): string
    {
        return '$arguments = func_get_args();' . PHP_EOL;
    }

    /**
     * @psalm-param class-string $fullClassName
     */
    protected function buildCallParentMethodCode(string $fullClassName, string $methodName): string
    {
        # Note that the parent class "parent::" calls here is actually the original class, which is $fullClassName
        if (!method_exists($fullClassName, $methodName)) {
            return '';
        }
        return "parent::{$methodName}(...\$arguments);" . PHP_EOL;
    }
}
